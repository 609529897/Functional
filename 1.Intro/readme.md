# Intro

## 运算

### 数值运算

跟其他语言基本一致，唯一区别是负数需要包裹起来，如 `1 * (-2)`

### 逻辑运算

```haskell

布尔值: True 和 False

取反: not False

与: &&

或: ||

```

### 关系运算

```haskell

等于 ==

不等于 /=

```

> 5 + 4.0 不会报错，编译器会任务 5 可以当作浮点数和整数

## 函数调用

### 中缀函数 infix function

中缀函数调用类似于夹三明治的函数，如数值运算符 `1 + 2`

### 前缀函数 prefix function

前缀函数调用 `函数名 ...参数列表`， `succ 8`，haskell 大部分函数都是前缀函数

```haskell

succ 7 -- 取得参数后继

min 8 9 -- 取小 （只接受两个参数）

max 7 0 -- 取大 （只接受两个参数）

```

函数拥有最高的优先权

```haskell
succ 9 + max 8 9 + 1 --等价于

(succ 9) + (max 8 9) + 1
```

如果函数的参数是两个的话可以使用 ``, 前缀函数变中缀函数

```haskell

-- div 获得两个数的商，不取余数

div 2 9 --变

2 `div` 9

```

## 函数声明

```haskell

doubleMe x = x + x

doubleUs x y = x * 2 + y * 2

```

### 装载函数

`:l 文件名`


### if else 

在 hs 中 else 部分是不可以省略的，因为在函数式语言中有输入就一定要有结果，而命令式语言中可以省略 else 这样可能不满足 if 的条件下啥也不做，也不用返回结果。而函数式语言这种必须要有返

haskell 中 if 是必定返回结果的表达式 （expression），而非语句（statement）

```haskell

doubleSmallNumber x = if x > 100
                      then x
                      else x * 2

```

if else 求出结果后可以进一步调用

`'` 是一个合法的字符串，有两个约定：

- 一般用于区分这是某函数的严格求值（与惰性求值相对）

- 或者是一个稍经修改但跟原有的函数差别不大的函数

```haskell

doubleSmallNumber' x = (if x > 100 then x else x * 2) + 1

```

没有参数的函数，称作定义或者名字，从此 conanO'Brien 和 "It's a-me, Conan O'Brien!" 等价

```haskell

conanO'Brien = "It's a-me, Conan O'Brien!"

```

## 列表入门

单类型数据结构，值只能是一种数据机构数值或字符串,不能混搭

列表也是可以嵌套的，但是值的类型必须要一致

### 定义 `let`

```haskell

-- 使用 let 定义常量
let arr = [1, 2, 3, 4]

```
### 拼接 `++` ， `:`

```haskell
【1, 2, 3】 ++ [2, 4, 4]

[1, 2, 3] ++ [4] -- 添加单元素也要是列表

"hello" ++ "word"

['w','o'] ++ ['o','t'] -- "woot"
```
> 字符串实际就是链表 “hello” 只是 ['h','e','l','l','o'] 的语法糖

如果对长列表进行 `++` 操作时注意，`++` 会遍历左边的列表，所以可能会比较耗时

当要在头部加入元素时可以使用运算符 `:` （Cons运算符）

```haskell

'A':" SMALL CAT" -- "A SMALL CAT"

5:[1, 2, 3] -- [5, 1, 2, 3]

```

### 取值 !!

```haskell
[1, 2, 3] !! 1 -- 2 使用索引取值
```

### 比较列表

`>` `<` `>=` `<=`

列表会依次比较值，列表长度不一样也可以比较，但是值类型类型必须要一致


```haskell
[1, 2, 4] > [1, 2, 5] -- False

[] < [1] -- 非空列表总是比空列表大

-- 1 > 1 -> 2 > 2 -> 4 > 5

```

### 列表操作

取单个值

```haskell
head [1, 2, 4] -- 1 返回列表头一个值

tail [1, 2, 4] -- [2, 4] 返回去掉头值的列表

last [1, 2, 4] -- 4 最后一个值

init [1, 2, 4] -- [1, 2] 返回去除最后一个值的列表 
```

容量操作

```haskell

length [1, 2, 4] -- 长度

null [] -- True 判断是否为空

reverse [1, 2] -- [2, 1] 反转列表

```

取多个值

```haskell
take 2 [1, 2] -- [1, 2] 取得列表的前几项组成新的列表

take 5 [1, 2] -- [1, 2] 而且第一个参数可以比列表长度大

drop 1 [1, 2] -- [2] 删除前几个值

maximum [1, 2, 4] -- 4 返回最大值

minimum [1, 2] --1 返回最小值
```

数值运算

```haskell

sum [1, 2, 4] -- 7 和

product [1, 2, 4] -- 8 积

4 `elem` [1, 2, 4] -- True 列表是否包含某一个值

```

### 生产列表

可以快速的获得一个长列表，前置条件是这个长列表的值必须是可枚举的

```haskell
[1...20] -- 1 到 20
['a'...'z'] -- a 到 z
['tom'...'jerry'] -- error 不可枚举
```

```haskell
-- 进阶，自己找规律
[2, 4 .... 16] -- 获得 2 到 16 所有 2 的倍数
[3, 6 .... 21] -- 3 的倍数
```

> ⚠️ `[20...1]` 不能获得 20 到 1，haskell 的构造新列表的逻辑是会生成一个空列表并会不停的增长。`[20, 19...1]` 可以获得想要的值

```haskell
[13, 26...13*24] -- 获得 24 个 13 的倍数
take 24 [13, 26...] -- 无限长的列表，因为 haskell 惰性求值，所以这是合法的，haskell 只是把前 24 个值给你让后就完事
```

生产无限列表的函数 `cycle` ，`repeat` ，`replicate` 

```haskell
take 4 (cycle [1, 2, 3]) -- [1, 2, 3, 1]
take 2 (cycle "lol ") -- "lol lol"

-- 接受一个参数，并生成这个参数的无限列表
take 2 (repeat 5) 

-- 一个参数一个长度，获得列表
replicate 2 10 -- [10, 10]
```

> ⚠️ 使用浮点数区间时要小心，因为浮点数精度不够，所以可能得到不太精确的值如：
>
>  `[0.1, 0.3...1]` 会得到  `[0.1, 0,3, 0.5, 0.7, 0.899999]`

---

### 列表推导式

```haskell
[x | x <- [50...100], x `mod` 7 == 3]
值 ｜值 <- 范围, 推导条件，推导条件
```

```haskell
[x * 2 | x <- [1..5]] -- [2, 4, 6, 8, 10]
[x * 2 | x <- [1..10], x * 2 >= 12] -- [12, 14, 16, 18, 20]
[x | x <- [50...100], x `mod` 7 == 3]
```

```haskell
boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x ]

[x + y | x <- [1, 2, 3], y <- [10, 100, 1000]] -- 从列表中取值
-- [11, 101, 1001, 12, 102, 1002, 13, 103, 1003]
```

> 我们可以认为 ｜ 后面的条件需要是 True ( x <- xs ）返回 True, （odd x）返回 True
>
> odd 函数接受一个参数，偶数返回 Flase a，奇数返回 True

```haskell
-- 模拟 length
length' xs = sum [1 | _ <- xs]

-- 字符串也是列表
removeNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]
```

```haskell
let xxs = [[1, 2, 3], 
           [4, 5, 6],
           [7, 8, 9]
           ]
[[x | x <- xs, even x ] | xs <- xss]
```

> 其实这个可以从后面开始往前推导
>
> odd. 是不是奇数
>
> even 是不是偶数

## 元组

- 长度固定
- 值可以是不同类型
- 有两个元素的被称为 `pair` 序对，三个元素 `triple` 三元组

```haskell
(1, "1", "2")

-- 长度不一样的元素认为是不同类型，每一项的类型不同都认为不合法
-- 以下都不合法
[(1, 2), (2, 2, "4"), (1, 2)]
[(1, 3), ("1", 2)]
(1)
(1, 2) > (1, 2, 4)
```

### 序对

```haskell
-- 只对序对有效
fst (1, 2) -- 1
snd (1, 2) -- 2

zip [1, 2] ["a", "b"] -- (1, "a"),(2, "b")
zip [1, 2] ["a"] -- (1, "a")
zip [1..] ("a", "b") -- (1, "a"),(2, "b")
```

取一个直角三角形

```haskell
let rightTrianles' = [(a, b, c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 = c^2, a + b + c == 24]
```

## 类型

### intro

- 类型推导
- `:t` 指令可以直接获得值的类型如： `:t 'a'` 返回 `'a'::Char`
- `::` 意思是：类型为
  - 如果你不知道自己函数类型是啥样的，可以先写函数让后使用 `:t` 进行检查，在书写

```haskell
removeNonUppercase::[Char] -> [Char]
removeNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]
```

```haskell
-- 多参数
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
```

### 常见类型